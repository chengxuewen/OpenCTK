---
name: "project-cpp-namespace-style"
description: "OpenCTK project C++ namespace style. Invoke when working on OpenCTK C++ code to follow the project's namespace style."
---

# OpenCTK 项目 C++ 命名空间风格指南

[English Version](../namespace.md)

## 概述

本文档描述了 OpenCTK 项目中使用的 C++ 命名空间风格规范。遵循这些规范可以确保代码库的一致性，提高代码的可读性和可维护性。

## 核心原则

1. **一致性**：在整个项目中遵循相同的命名空间规范
2. **清晰性**：命名空间名称应清晰反映其功能或模块
3. **避免污染**：避免使用过多的全局命名空间
4. **层次结构**：使用嵌套命名空间创建清晰的层次结构
5. **可扩展性**：设计命名空间结构以支持未来的扩展

## 全局命名空间

### 使用 `OCTK_BEGIN_NAMESPACE` 和 `OCTK_END_NAMESPACE` 宏

OpenCTK 项目使用自定义宏来定义全局命名空间，这些宏封装了实际的命名空间名称，便于未来可能的重构。

**示例：**
```cpp
OCTK_BEGIN_NAMESPACE

// 公共代码放在 octk 命名空间中
class String
{
    // ...
};

OCTK_END_NAMESPACE
```

### 宏定义

这些宏通常定义在全局头文件中（如 `octk_global.hpp`），实际展开为：

```cpp
#define OCTK_BEGIN_NAMESPACE namespace octk \
{ \
    namespace detail \
    { \
        namespace thread \
        { 
#define OCTK_END_NAMESPACE } \
    } \
}
```

## 嵌套命名空间

### 功能模块命名空间

对于不同的功能模块，使用嵌套命名空间来组织代码：

**示例：**
```cpp
OCTK_BEGIN_NAMESPACE

namespace string_utils
{
    std::string toUpper(const std::string &str);
    std::string toLower(const std::string &str);
}

namespace network
{
    class Socket
    {
        // ...
    };
}

OCTK_END_NAMESPACE
```

### 实现细节命名空间

对于内部实现细节，使用 `detail` 命名空间进行封装：

**示例：**
```cpp
OCTK_BEGIN_NAMESPACE

class PublicClass
{
private:
    // 公共类的实现细节
    class PrivateImpl;
    std::unique_ptr<PrivateImpl> d_ptr;
};

namespace detail
{
    // 内部实现细节，不对外暴露
    void internalFunction()
    {
        // ...
    }
}

OCTK_END_NAMESPACE
```

## 外部命名空间

### WebRTC 命名空间

当集成或依赖 WebRTC 库时，使用 `webrtc` 命名空间：

**示例：**
```cpp
namespace webrtc
{
    // WebRTC 相关代码
    class VideoEncoder
    {
        // ...
    };
}
```

### 标准库命名空间

使用标准库命名空间时，应明确指定 `std::` 前缀，避免使用 `using namespace std;`：

**推荐：**
```cpp
std::string str = "Hello";
std::vector<int> vec;
```

**不推荐：**
```cpp
using namespace std;
string str = "Hello";
vector<int> vec;
```

## 匿名命名空间

对于仅在当前文件中使用的代码，使用匿名命名空间：

**示例：**
```cpp
OCTK_BEGIN_NAMESPACE

namespace {
    // 仅在当前文件中使用的常量
    const int kMaxBufferSize = 1024;
    
    // 仅在当前文件中使用的函数
    void helperFunction() {
        // ...
    }
}

// 公共代码
void publicFunction() {
    helperFunction();
}

OCTK_END_NAMESPACE
```

## 命名空间命名规范

1. **使用小写字母**：命名空间名称应使用小写字母
2. **使用下划线分隔**：对于多个单词组成的命名空间名称，使用下划线分隔
3. **反映功能**：命名空间名称应清晰反映其功能或模块
4. **避免缩写**：尽可能使用完整单词，除非缩写是广泛接受的

**示例：**
```cpp
// 推荐
namespace network_utils {
    // ...
}

namespace media_codec {
    // ...
}

// 不推荐
namespace netutils {
    // ...
}

namespace mc {
    // ...
}
```

## 命名空间的使用方式

### 完整限定名

对于不频繁使用的命名空间成员，使用完整限定名：

**示例：**
```cpp
octk::string_utils::toUpper("hello");
```

### 命名空间别名

对于长命名空间，可以使用命名空间别名简化代码：

**示例：**
```cpp
namespace octk_net = octk::network;
octk_net::Socket socket;
```

### 局部 using 声明

对于频繁使用的命名空间成员，可以在函数或类内部使用 `using` 声明：

**示例：**
```cpp
void processString() {
    using octk::string_utils::toUpper;
    using octk::string_utils::toLower;
    
    std::string str = "Hello";
    std::string upper = toUpper(str);
    std::string lower = toLower(str);
}
```

## 最佳实践

1. **保持命名空间层次简洁**：避免过深的命名空间嵌套（建议不超过3层）
2. **每个命名空间有明确的职责**：一个命名空间应包含相关的功能
3. **避免命名空间污染**：不要在头文件中使用 `using namespace`
4. **使用命名空间封装实现细节**：将内部实现放在 `detail` 命名空间中
5. **遵循一致的命名规范**：所有命名空间名称遵循相同的命名风格
6. **文档化命名空间**：为每个命名空间添加简短的文档注释

## 常见错误避免

1. **在头文件中使用 `using namespace`**：这会污染所有包含该头文件的代码
2. **过深的命名空间嵌套**：会导致代码冗长，降低可读性
3. **不明确的命名空间名称**：名称应清晰反映其功能
4. **混合不同命名空间的代码**：相关功能应放在同一个命名空间中
5. **未使用命名空间封装内部实现**：内部实现应放在 `detail` 命名空间中

## 示例代码

### 正确的命名空间使用

```cpp
// octk_string.hpp
OCTK_BEGIN_NAMESPACE

/**
 * @namespace octk::string_utils
 * @brief String utility functions
 */
namespace string_utils {
    /**
     * @brief Convert string to uppercase
     * @param str Input string
     * @return Uppercase string
     */
    std::string toUpper(const std::string &str);
    
    /**
     * @brief Convert string to lowercase
     * @param str Input string
     * @return Lowercase string
     */
    std::string toLower(const std::string &str);
}

OCTK_END_NAMESPACE
```

```cpp
// octk_string.cpp
#include <octk_string.hpp>
#include <algorithm>

OCTK_BEGIN_NAMESPACE

namespace string_utils {
    std::string toUpper(const std::string &str) {
        std::string result = str;
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        return result;
    }
    
    std::string toLower(const std::string &str) {
        std::string result = str;
        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
        return result;
    }
}

OCTK_END_NAMESPACE
```

### 使用示例

```cpp
#include <octk_string.hpp>
#include <iostream>

int main() {
    std::string str = "Hello, OpenCTK!";
    
    // 使用完整限定名
    std::string upper = octk::string_utils::toUpper(str);
    std::string lower = octk::string_utils::toLower(str);
    
    std::cout << "Original: " << str << std::endl;
    std::cout << "Uppercase: " << upper << std::endl;
    std::cout << "Lowercase: " << lower << std::endl;
    
    return 0;
}
```

## 结论

遵循这些命名空间风格规范可以确保 OpenCTK 项目代码的一致性和可读性。命名空间是 C++ 中组织代码的重要机制，正确使用命名空间可以避免名称冲突，提高代码的模块化和可维护性。

在开发 OpenCTK 项目时，请始终参考本文档和其他相关风格指南，确保代码符合项目的命名空间规范。

[English Version](../namespace.md)