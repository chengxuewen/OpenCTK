---
name: "project-cpp-code-format"
description: "OpenCTK项目C++代码格式风格。在处理OpenCTK C++代码时调用，以遵循项目的代码格式规则。"
---

# OpenCTK项目C++代码格式风格指南

[English Version](../code-format.md)

## 概述

本文档描述了OpenCTK项目中使用的C++代码格式规范。项目使用带有自定义配置的ClangFormat来确保整个代码库的代码格式一致性。

## 核心原则

1. **一致性**：所有代码应遵循相同的格式规则
2. **可读性**：格式应增强代码的可读性
3. **自动执行**：使用ClangFormat自动格式化代码
4. **版本控制友好**：格式应最小化版本控制中的差异
5. **现代C++支持**：支持现代C++特性和语法

## ClangFormat配置

项目使用位于仓库根目录的自定义`.clang-format`文件。该文件定义了项目的所有格式规则。

### 关键配置点

#### 基本风格
- **基础风格**：基于LLVM风格
- **缩进宽度**：4个空格（不使用制表符）
- **列限制**：120个字符

#### 大括号风格
- **大括号风格**：Allman风格（左大括号另起一行）
- **大括号前空格**：仅控制语句
- **缩进大括号**：是

#### 缩进
- **访问修饰符偏移**：-4个空格
- **缩进case标签**：是
- **缩进预处理指令**：在#之后

#### 空格
- **模板关键字后空格**：是
- **赋值操作符前空格**：是
- **空块内空格**：是
- **指针对齐**：右对齐（例如：`int* ptr`）

#### 换行
- **参数打包**：否（每个参数单独一行）
- **参数列表打包**：否（每个参数单独一行）
- **始终中断模板声明**：是

## 代码格式示例

### 命名空间

```cpp
OCTK_BEGIN_NAMESPACE

namespace detail
{
    // 命名空间内容
}

OCTK_END_NAMESPACE
```

### 类和结构体

```cpp
class LoggerPrivate
{
public:
    LoggerPrivate(Logger* p, const char* name)
        : mPPtr(p)
        , mIdNumber(detail::loggerIdNumberCounter().fetch_add(1))
        , mName(name)
        , mNoSource(false)
    {
        // 构造函数内容
    }
    
    ~LoggerPrivate() { }
    
private:
    Logger* mPPtr;
    int mIdNumber;
    std::string mName;
    bool mNoSource;
};
```

### 函数

```cpp
static inline std::mutex& loggersMapMutex()
{
    static std::mutex mutex;
    return mutex;
}

bool LoggerPrivate::messageHandlerOutput(const Context& context, const char* message)
{
    const auto handlerWraper = mMessageHandlerWraper.load();
    if (handlerWraper)
    {
        handlerWraper->handler(mName, context, message);
        return mMessageHandleUniqueOwnership.load();
    }
    return false;
}
```

### 控制语句

```cpp
if (condition)
{
    // if语句体
}
else if (otherCondition)
{
    // else if语句体
}
else
{
    // else语句体
}

for (int i = 0; i < 10; ++i)
{
    // for循环体
}

while (condition)
{
    // while循环体
}

switch (value)
{
    case 1:
        // case 1语句体
        break;
    case 2:
        // case 2语句体
        break;
    default:
        // default语句体
        break;
}
```

### 模板声明

```cpp
template <typename T>
class Vector
{
public:
    // 类内容
};

template <typename IteratorType, typename ValueType>
IteratorType find(IteratorType begin, IteratorType end, const ValueType& value)
{
    // 函数内容
}
```

## 如何使用ClangFormat

### 格式化文件

格式化单个文件：
```bash
clang-format -i file.cpp
```

格式化目录中的所有C++文件：
```bash
find . -name "*.cpp" -o -name "*.hpp" | xargs clang-format -i
```

### IDE集成

大多数现代IDE都支持ClangFormat集成：

- **Visual Studio Code**：安装Clang-Format扩展并启用保存时格式化
- **CLion**：在设置 > 编辑器 > 代码风格 > C/C++ 中启用ClangFormat支持
- **Visual Studio**：安装ClangFormat扩展并将其配置为使用项目的.clang-format文件

### Git钩子

您可以设置预提交钩子来自动格式化更改的文件：

```bash
#!/bin/sh

git diff --cached --name-only --diff-filter=ACM | grep -E \.(cpp|hpp)$ | xargs clang-format -i
git add -u
```

## 最佳实践

1. **尽早格式化，经常格式化**：定期格式化代码，避免大的格式更改
2. **遵循现有风格**：修改现有代码时，遵循该文件的风格
3. **使用ClangFormat**：始终使用ClangFormat确保一致性
4. **不要对抗格式**：如果ClangFormat以您不喜欢的方式格式化某些内容，考虑调整代码结构而不是禁用格式化
5. **审查格式更改**：审查PR时，注意格式更改以确保它们一致

## 常见问题和解决方案

### 长行
- **问题**：代码超过120个字符的列限制
- **解决方案**：在逻辑点（例如逗号、操作符后）换行

### 复杂表达式
- **问题**：即使格式化后，复杂表达式也难以阅读
- **解决方案**：将复杂表达式分解为多行，使用中间变量

### 模板声明
- **问题**：长模板声明难以格式化
- **解决方案**：让ClangFormat使用`AlwaysBreakTemplateDeclarations: Yes`自动处理

## 结论

一致的代码格式对于维护大型代码库至关重要。通过遵循OpenCTK项目的代码格式规则并使用ClangFormat，您可以确保您的代码与项目的其余部分一致，使其更易于阅读、理解和维护。

格式化代码时，请始终参考本文档和项目的`.clang-format`文件。如有疑问，让ClangFormat自动处理格式化。