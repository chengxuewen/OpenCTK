---
name: "project-cpp-code-naming"
description: "OpenCTK项目C++代码命名风格。在编写OpenCTK C++代码时调用，以遵循项目的代码命名规则。"
---

# OpenCTK 项目 C++ 代码命名风格指南

[English Version](../code-naming.md)

## 概述

本文档描述了 OpenCTK 项目中使用的 C++ 代码命名规范。遵循这些规范可以确保代码库的一致性，提高代码的可读性和可维护性。

## 核心原则

1. **一致性**：在整个项目中遵循相同的命名规范
2. **清晰性**：名称应清晰反映其用途和功能
3. **可读性**：选择易于阅读和理解的名称
4. **简洁性**：保持名称简洁但描述性
5. **避免歧义**：名称不应与其他实体容易混淆

## 按实体类型划分的命名规范

### 1. 命名空间名称

- **风格**：snake_case（小写字母加下划线）
- **使用场景**：用于组织相关功能
- **示例**：
  ```cpp
  namespace string_utils
  {
      // ...
  }
  
  namespace media_codec
  {
      // ...
  }
  ```

### 2. 类和结构体名称

- **风格**：PascalCase（每个单词首字母大写）
- **单数形式**：使用单数形式
- **描述性**：清晰表明实体的用途
- **示例**：
  ```cpp
  struct ActiveSpatialLayers
  {
      // ...
  };
  
  class VideoEncoder
  {
      // ...
  };
  ```

### 3. 函数和方法名称

- **风格**：snake_case（小写字母加下划线）
- **动词开头**：使用动词表示动作
- **清晰的用途**：名称应清楚描述函数的功能
- **示例**：
  ```cpp
  std::vector<std::string> split(const std::string& str, char delimiter);
  
  std::string to_upper(const std::string& str);
  
  bool try_parse_int(const std::string& str, int& out_value);
  ```

### 4. 变量名称

- **风格**：snake_case（小写字母加下划线）
- **描述性**：清晰表明变量的用途
- **避免单字母**：简单循环变量（i, j, k）除外
- **示例**：
  ```cpp
  std::vector<std::string> tokens;
  std::stringstream ss(str);
  std::string token;
  ```

### 5. 函数参数

- **风格**：snake_case（小写字母加下划线）
- **描述性**：清晰表明参数的用途
- **输出参数**：使用 `out_` 前缀
- **示例**：
  ```cpp
  bool try_parse_int(const std::string& str, int& out_value);
  
  std::string replace_all(const std::string& str, const std::string& from, const std::string& to);
  ```

### 6. 常量

- **风格**：kCamelCase（k 前缀加 CamelCase）
- **描述性**：清晰表明常量的用途
- **示例**：
  ```cpp
  constexpr float kTemporalLayeringRateScalingFactor = 0.55f;
  
  static constexpr char hex_digits[] = "0123456789ABCDEF";
  ```

### 7. 枚举和枚举值

- **枚举名称**：PascalCase
- **枚举值**：kCamelCase（首选）或 ALL_CAPS
- **示例**：
  ```cpp
  enum class VideoCodecType
  {
      kH264,
      kVP8,
      kVP9,
      kAV1
  };
  
  // 替代风格
  enum ColorFormat
  {
      COLOR_FORMAT_RGB,
      COLOR_FORMAT_YUV420,
      COLOR_FORMAT_YUV422,
      COLOR_FORMAT_YUV444
  };
  ```

### 8. 宏

- **风格**：ALL_CAPS_WITH_UNDERSCORES（全部大写加下划线）
- **避免不必要的宏**：优先使用常量或 constexpr 函数
- **示例**：
  ```cpp
  #define OCTK_MAX_BUFFER_SIZE 1024
  
  #define OCTK_ASSERT(x) assert(x)
  ```

### 9. 模板参数

- **简单参数**：单个大写字母
- **复杂参数**：描述性 PascalCase
- **示例**：
  ```cpp
  template <typename T>  // 简单模板参数
  class Vector
  {
      // ...
  };
  
  template <typename IteratorType, typename ValueType>  // 描述性模板参数
  IteratorType find(IteratorType begin, IteratorType end, const ValueType& value)
  {
      // ...
  }
  ```

## 按作用域划分的命名规范

### 1. 全局变量

- **尽可能避免使用**：优先使用局部变量或单例模式
- **如必须使用**：使用 `g_` 前缀
- **示例**：
  ```cpp
  int g_global_counter = 0;
  ```

### 2. 成员变量

- **风格**：`m` 前缀加驼峰命名（OpenCTK 首选）
- **使用场景**：所有非静态成员变量
- **示例**：
  ```cpp
  // OpenCTK 首选风格
  class VideoEncoder
  {
  private:
      int mFrameCount;
      std::string mCodecName;
  };
  
  // 替代风格（不推荐）
  class AudioDecoder
  {
  private:
      int m_frame_count; // m_ 前缀加 snake_case（不推荐）
      int sampleRate;    // 无前缀加驼峰命名（不推荐）
      int sample_rate;   // 无前缀加 snake_case（不推荐）
  };
  ```

### 3. 静态成员变量

- **风格**：kCamelCase（与常量相同）
- **示例**：
  ```cpp
  class Log
  {
  private:
      static LogLevel kDefaultLogLevel;
  };
  ```

## 最佳实践

1. **保持一致**：在整个代码库中遵循相同的命名规范
2. **使用描述性名称**：避免缩写，除非它们被广泛接受
3. **保持名称简洁**：在描述性的同时，避免过长的名称
4. **为函数使用有意义的动词**：选择清晰表明函数动作的动词
5. **避免匈牙利命名法**：现代 C++ 不需要类型前缀
6. **仅在特殊情况下使用前缀**：如 `out_` 用于输出参数或 `g_` 用于全局变量
7. **遵循项目现有风格**：如有疑问，查看现有代码
8. **记录不明确的名称**：如果名称不是自解释的，添加注释

## 常见错误避免

1. **命名不一致**：在同一文件中混合使用不同的命名风格
2. **名称过短**：不能清晰表明用途的名称
3. **晦涩的缩写**：不被广泛理解的缩写
4. **使用保留字**：避免使用 C++ 关键字作为名称
5. **匈牙利命名法**：使用类型前缀如 `iCount` 或 `strName`
6. **误导性名称**：不能准确描述实体功能的名称
7. **名称过长**：不必要的冗长名称

## 良好和不良命名示例

### 良好示例
```cpp
// 清晰的函数名称和描述性参数
bool try_parse_double(const std::string& str, double& out_value);

// 描述性变量名称
std::string formatted_string = to_fixed_string(value, 2);

// 清晰的常量名称
constexpr float kMaxFrameRate = 60.0f;
```

### 不良示例
```cpp
// 不清晰的函数名称
bool parse(const std::string& s, double& v);

// 名称过短
std::string fs = tf(value, 2);

// 晦涩的常量名称
constexpr float m = 60.0f;
```

## 结论

遵循这些代码命名规范可以确保 OpenCTK 代码库的一致性、可读性和可维护性。一致的命名使代码更易于理解、调试和修改，这对于大型项目至关重要。

在 OpenCTK 项目中编写新代码或修改现有代码时，请始终参考本文档。如有疑问，请遵循您正在处理的文件或模块中的现有风格。

[English Version](../code-naming.md)